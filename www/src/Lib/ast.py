"""
    ast
    ~~~

    The `ast` module helps Python applications to process trees of the Python
    abstract syntax grammar.  The abstract syntax itself might change with
    each Python release; this module helps to find out programmatically what
    the current grammar looks like and allows modifications of it.

    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
    a flag to the `compile()` builtin function or by using the `parse()`
    function from this module.  The result will be a tree of objects whose
    classes all inherit from `ast.AST`.

    A modified abstract syntax tree can be compiled into a Python code object
    using the built-in `compile()` function.

    Additionally various helper functions are provided that make working with
    the trees simpler.  The main intention of the helper functions and this
    module in general is to provide an easy to use interface for libraries
    that work tightly with the python syntax (template engines for example).


    :copyright: Copyright 2008 by Armin Ronacher.
    :license: Python License.
"""

import enum
from contextlib import nullcontext

class AST(object):

    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class alias(AST):
    """alias(identifier name, identifier? asname)"""


    __match_args__ = "('name', 'asname')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('name', 'asname')"

    asname = None

    end_col_offset = None

    end_lineno = None

class arg(AST):
    """arg(identifier arg, expr? annotation, string? type_comment)"""


    __match_args__ = "('arg', 'annotation', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('arg', 'annotation', 'type_comment')"

    annotation = None

    end_col_offset = None

    end_lineno = None

    type_comment = None

class arguments(AST):
    """arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)"""


    __match_args__ = "('posonlyargs', 'args', 'vararg', 'kwonlyargs', 'kw_defaults', 'kwarg', 'defaults')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('posonlyargs', 'args', 'vararg', 'kwonlyargs', 'kw_defaults', 'kwarg', 'defaults')"

    kwarg = None

    vararg = None


class operator(AST):
    """operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class boolop(AST):
    """boolop = And | Or"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class cmpop(AST):
    """cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class comprehension(AST):
    """comprehension(expr target, expr iter, expr* ifs, int is_async)"""


    __match_args__ = "('target', 'iter', 'ifs', 'is_async')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('target', 'iter', 'ifs', 'is_async')"

class match_case(AST):
    """match_case(pattern pattern, expr? guard, stmt* body)"""


    __match_args__ = "('pattern', 'guard', 'body')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('pattern', 'guard', 'body')"

    guard = None

class mod(AST):
    """mod = Module(stmt* body, type_ignore* type_ignores)
        | Interactive(stmt* body)
        | Expression(expr body)
        | FunctionType(expr* argtypes, expr returns)"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"


class keyword(AST):
    """keyword(identifier? arg, expr value)"""


    __match_args__ = "('arg', 'value')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('arg', 'value')"

    arg = None

    end_col_offset = None

    end_lineno = None

class pattern(AST):
    """pattern = MatchValue(expr value)
            | MatchSingleton(constant value)
            | MatchSequence(pattern* patterns)
            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)
            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)
            | MatchStar(identifier? name)
            | MatchAs(pattern? pattern, identifier? name)
            | MatchOr(pattern* patterns)"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

class slice(AST):
    """Deprecated AST node class."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class stmt(AST):
    """stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)
         | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)
         | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)
         | Return(expr? value)
         | Delete(expr* targets)
         | Assign(expr* targets, expr value, string? type_comment)
         | AugAssign(expr target, operator op, expr value)
         | AnnAssign(expr target, expr annotation, expr? value, int simple)
         | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
         | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
         | While(expr test, stmt* body, stmt* orelse)
         | If(expr test, stmt* body, stmt* orelse)
         | With(withitem* items, stmt* body, string? type_comment)
         | AsyncWith(withitem* items, stmt* body, string? type_comment)
         | Match(expr subject, match_case* cases)
         | Raise(expr? exc, expr? cause)
         | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
         | Assert(expr test, expr? msg)
         | Import(alias* names)
         | ImportFrom(identifier? module, alias* names, int? level)
         | Global(identifier* names)
         | Nonlocal(identifier* names)
         | Expr(expr value)
         | Pass
         | Break
         | Continue"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None
sys = "<module 'sys' (built-in)>"


class type_ignore(AST):
    """type_ignore = TypeIgnore(int lineno, string tag)"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class unaryop(AST):
    """unaryop = Invert | Not | UAdd | USub"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"


class withitem(AST):
    """withitem(expr context_expr, expr? optional_vars)"""


    __match_args__ = "('context_expr', 'optional_vars')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('context_expr', 'optional_vars')"

    optional_vars = None

class excepthandler(AST):
    """excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None

class expr(AST):
    """expr = BoolOp(boolop op, expr* values)
         | NamedExpr(expr target, expr value)
         | BinOp(expr left, operator op, expr right)
         | UnaryOp(unaryop op, expr operand)
         | Lambda(arguments args, expr body)
         | IfExp(expr test, expr body, expr orelse)
         | Dict(expr* keys, expr* values)
         | Set(expr* elts)
         | ListComp(expr elt, comprehension* generators)
         | SetComp(expr elt, comprehension* generators)
         | DictComp(expr key, expr value, comprehension* generators)
         | GeneratorExp(expr elt, comprehension* generators)
         | Await(expr value)
         | Yield(expr? value)
         | YieldFrom(expr value)
         | Compare(expr left, cmpop* ops, expr* comparators)
         | Call(expr func, expr* args, keyword* keywords)
         | FormattedValue(expr value, int? conversion, expr? format_spec)
         | JoinedStr(expr* values)
         | Constant(constant value, string? kind)
         | Attribute(expr value, identifier attr, expr_context ctx)
         | Subscript(expr value, expr slice, expr_context ctx)
         | Starred(expr value, expr_context ctx)
         | Name(identifier id, expr_context ctx)
         | List(expr* elts, expr_context ctx)
         | Tuple(expr* elts, expr_context ctx)
         | Slice(expr? lower, expr? upper, expr? step)"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None

class expr_context(AST):
    """expr_context = Load | Store | Del"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"


class NodeVisitor(object):
    """
        A node visitor base class that walks the abstract syntax tree and calls a
        visitor function for every node found.  This function may return a value
        which is forwarded by the `visit` method.

        This class is meant to be subclassed, with the subclass adding visitor
        methods.

        Per default the visitor functions for the nodes are ``'visit_'`` +
        class name of the node.  So a `TryFinally` node visit function would
        be `visit_TryFinally`.  This behavior can be changed by overriding
        the `visit` method.  If no visitor function exists for a node
        (return value `None`) the `generic_visit` visitor is used instead.

        Don't use the `NodeVisitor` if you want to apply changes to nodes during
        traversing.  For this a special visitor exists (`NodeTransformer`) that
        allows modifications.
        """


    __module__ = """ast"""

    def generic_visit(*args,**kw):
        """Called if no explicit visitor function exists for a node."""
        pass

    def visit(*args,**kw):
        """Visit a node."""
        pass

    def visit_Constant(*args,**kw):
        pass

class Add(operator):
    """Add"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class And(boolop):
    """And"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class AnnAssign(stmt):
    """AnnAssign(expr target, expr annotation, expr? value, int simple)"""


    __match_args__ = "('target', 'annotation', 'value', 'simple')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('target', 'annotation', 'value', 'simple')"

    end_col_offset = None

    end_lineno = None

    value = None

class Assert(stmt):
    """Assert(expr test, expr? msg)"""


    __match_args__ = "('test', 'msg')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('test', 'msg')"

    end_col_offset = None

    end_lineno = None

    msg = None

class Assign(stmt):
    """Assign(expr* targets, expr value, string? type_comment)"""


    __match_args__ = "('targets', 'value', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('targets', 'value', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    type_comment = None

class AsyncFor(stmt):
    """AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)"""


    __match_args__ = "('target', 'iter', 'body', 'orelse', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('target', 'iter', 'body', 'orelse', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    type_comment = None

class AsyncFunctionDef(stmt):
    """AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)"""


    __match_args__ = "('name', 'args', 'body', 'decorator_list', 'returns', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('name', 'args', 'body', 'decorator_list', 'returns', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    returns = None

    type_comment = None

class AsyncWith(stmt):
    """AsyncWith(withitem* items, stmt* body, string? type_comment)"""


    __match_args__ = "('items', 'body', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('items', 'body', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    type_comment = None

class Attribute(expr):
    """Attribute(expr value, identifier attr, expr_context ctx)"""


    __match_args__ = "('value', 'attr', 'ctx')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value', 'attr', 'ctx')"

    end_col_offset = None

    end_lineno = None

class AugAssign(stmt):
    """AugAssign(expr target, operator op, expr value)"""


    __match_args__ = "('target', 'op', 'value')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('target', 'op', 'value')"

    end_col_offset = None

    end_lineno = None

class AugLoad(expr_context):
    """Deprecated AST node class.  Unused in Python 3."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class AugStore(expr_context):
    """Deprecated AST node class.  Unused in Python 3."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Await(expr):
    """Await(expr value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

    end_col_offset = None

    end_lineno = None

class BinOp(expr):
    """BinOp(expr left, operator op, expr right)"""


    __match_args__ = "('left', 'op', 'right')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('left', 'op', 'right')"

    end_col_offset = None

    end_lineno = None

class BitAnd(operator):
    """BitAnd"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class BitOr(operator):
    """BitOr"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class BitXor(operator):
    """BitXor"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class BoolOp(expr):
    """BoolOp(boolop op, expr* values)"""


    __match_args__ = "('op', 'values')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('op', 'values')"

    end_col_offset = None

    end_lineno = None

class Break(stmt):
    """Break"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None


class Constant(expr):
    """Constant(constant value, string? kind)"""


    __match_args__ = "('value', 'kind')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value', 'kind')"

    end_col_offset = None

    end_lineno = None

    kind = None

    n = "<property object at 0x000001303F3F2D40>"

    s = "<property object at 0x000001303F7F6AC0>"

class Bytes(Constant):
    """Deprecated AST node class. Use ast.Constant instead"""


    __match_args__ = "('value', 'kind')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('s',)"

    end_col_offset = None

    end_lineno = None

    kind = None

    n = "<property object at 0x000001303F3F2D40>"

    s = "<property object at 0x000001303F7F6AC0>"

class Call(expr):
    """Call(expr func, expr* args, keyword* keywords)"""


    __match_args__ = "('func', 'args', 'keywords')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('func', 'args', 'keywords')"

    end_col_offset = None

    end_lineno = None

class ClassDef(stmt):
    """ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)"""


    __match_args__ = "('name', 'bases', 'keywords', 'body', 'decorator_list')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('name', 'bases', 'keywords', 'body', 'decorator_list')"

    end_col_offset = None

    end_lineno = None

class Compare(expr):
    """Compare(expr left, cmpop* ops, expr* comparators)"""


    __match_args__ = "('left', 'ops', 'comparators')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('left', 'ops', 'comparators')"

    end_col_offset = None

    end_lineno = None


class Continue(stmt):
    """Continue"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None

class Del(expr_context):
    """Del"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Delete(stmt):
    """Delete(expr* targets)"""


    __match_args__ = "('targets',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('targets',)"

    end_col_offset = None

    end_lineno = None

class Dict(expr):
    """Dict(expr* keys, expr* values)"""


    __match_args__ = "('keys', 'values')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('keys', 'values')"

    end_col_offset = None

    end_lineno = None

class DictComp(expr):
    """DictComp(expr key, expr value, comprehension* generators)"""


    __match_args__ = "('key', 'value', 'generators')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('key', 'value', 'generators')"

    end_col_offset = None

    end_lineno = None

class Div(operator):
    """Div"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Ellipsis(Constant):
    """Deprecated AST node class. Use ast.Constant instead"""


    __match_args__ = "('value', 'kind')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None

    kind = None

    n = "<property object at 0x000001303F3F2D40>"

    s = "<property object at 0x000001303F7F6AC0>"

class Eq(cmpop):
    """Eq"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class ExceptHandler(excepthandler):
    """ExceptHandler(expr? type, identifier? name, stmt* body)"""


    __match_args__ = "('type', 'name', 'body')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('type', 'name', 'body')"

    end_col_offset = None

    end_lineno = None

    name = None

    type = None

class Expr(stmt):
    """Expr(expr value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

    end_col_offset = None

    end_lineno = None

class Expression(mod):
    """Expression(expr body)"""


    __match_args__ = "('body',)"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('body',)"

class ExtSlice(slice):
    """Deprecated AST node class. Use ast.Tuple instead."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class FloorDiv(operator):
    """FloorDiv"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class For(stmt):
    """For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)"""


    __match_args__ = "('target', 'iter', 'body', 'orelse', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('target', 'iter', 'body', 'orelse', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    type_comment = None

class FormattedValue(expr):
    """FormattedValue(expr value, int? conversion, expr? format_spec)"""


    __match_args__ = "('value', 'conversion', 'format_spec')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value', 'conversion', 'format_spec')"

    conversion = None

    end_col_offset = None

    end_lineno = None

    format_spec = None

class FunctionDef(stmt):
    """FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)"""


    __match_args__ = "('name', 'args', 'body', 'decorator_list', 'returns', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('name', 'args', 'body', 'decorator_list', 'returns', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    returns = None

    type_comment = None

class FunctionType(mod):
    """FunctionType(expr* argtypes, expr returns)"""


    __match_args__ = "('argtypes', 'returns')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('argtypes', 'returns')"

class GeneratorExp(expr):
    """GeneratorExp(expr elt, comprehension* generators)"""


    __match_args__ = "('elt', 'generators')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('elt', 'generators')"

    end_col_offset = None

    end_lineno = None

class Global(stmt):
    """Global(identifier* names)"""


    __match_args__ = "('names',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('names',)"

    end_col_offset = None

    end_lineno = None

class Gt(cmpop):
    """Gt"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class GtE(cmpop):
    """GtE"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class If(stmt):
    """If(expr test, stmt* body, stmt* orelse)"""


    __match_args__ = "('test', 'body', 'orelse')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('test', 'body', 'orelse')"

    end_col_offset = None

    end_lineno = None

class IfExp(expr):
    """IfExp(expr test, expr body, expr orelse)"""


    __match_args__ = "('test', 'body', 'orelse')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('test', 'body', 'orelse')"

    end_col_offset = None

    end_lineno = None

class Import(stmt):
    """Import(alias* names)"""


    __match_args__ = "('names',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('names',)"

    end_col_offset = None

    end_lineno = None

class ImportFrom(stmt):
    """ImportFrom(identifier? module, alias* names, int? level)"""


    __match_args__ = "('module', 'names', 'level')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('module', 'names', 'level')"

    end_col_offset = None

    end_lineno = None

    level = None

    module = None

class In(cmpop):
    """In"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Index(slice):
    """Deprecated AST node class. Use the index value directly instead."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class IntEnum(int, enum.Enum):
    """Enum where members are also (and must be) ints"""


    __module__ = """enum"""

class Interactive(mod):
    """Interactive(stmt* body)"""


    __match_args__ = "('body',)"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('body',)"

class Invert(unaryop):
    """Invert"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Is(cmpop):
    """Is"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class IsNot(cmpop):
    """IsNot"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class JoinedStr(expr):
    """JoinedStr(expr* values)"""


    __match_args__ = "('values',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('values',)"

    end_col_offset = None

    end_lineno = None

class LShift(operator):
    """LShift"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Lambda(expr):
    """Lambda(arguments args, expr body)"""


    __match_args__ = "('args', 'body')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('args', 'body')"

    end_col_offset = None

    end_lineno = None

class List(expr):
    """List(expr* elts, expr_context ctx)"""


    __match_args__ = "('elts', 'ctx')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('elts', 'ctx')"

    end_col_offset = None

    end_lineno = None

class ListComp(expr):
    """ListComp(expr elt, comprehension* generators)"""


    __match_args__ = "('elt', 'generators')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('elt', 'generators')"

    end_col_offset = None

    end_lineno = None

class Load(expr_context):
    """Load"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Lt(cmpop):
    """Lt"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class LtE(cmpop):
    """LtE"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class MatMult(operator):
    """MatMult"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Match(stmt):
    """Match(expr subject, match_case* cases)"""


    __match_args__ = "('subject', 'cases')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('subject', 'cases')"

    end_col_offset = None

    end_lineno = None

class MatchAs(pattern):
    """MatchAs(pattern? pattern, identifier? name)"""


    __match_args__ = "('pattern', 'name')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('pattern', 'name')"

    name = None

    pattern = None

class MatchClass(pattern):
    """MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)"""


    __match_args__ = "('cls', 'patterns', 'kwd_attrs', 'kwd_patterns')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('cls', 'patterns', 'kwd_attrs', 'kwd_patterns')"

class MatchMapping(pattern):
    """MatchMapping(expr* keys, pattern* patterns, identifier? rest)"""


    __match_args__ = "('keys', 'patterns', 'rest')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('keys', 'patterns', 'rest')"

    rest = None

class MatchOr(pattern):
    """MatchOr(pattern* patterns)"""


    __match_args__ = "('patterns',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('patterns',)"

class MatchSequence(pattern):
    """MatchSequence(pattern* patterns)"""


    __match_args__ = "('patterns',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('patterns',)"

class MatchSingleton(pattern):
    """MatchSingleton(constant value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

class MatchStar(pattern):
    """MatchStar(identifier? name)"""


    __match_args__ = "('name',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('name',)"

    name = None

class MatchValue(pattern):
    """MatchValue(expr value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

class Mod(operator):
    """Mod"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Module(mod):
    """Module(stmt* body, type_ignore* type_ignores)"""


    __match_args__ = "('body', 'type_ignores')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('body', 'type_ignores')"

class Mult(operator):
    """Mult"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Name(expr):
    """Name(identifier id, expr_context ctx)"""


    __match_args__ = "('id', 'ctx')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('id', 'ctx')"

    end_col_offset = None

    end_lineno = None

class NameConstant(Constant):
    """Deprecated AST node class. Use ast.Constant instead"""


    __match_args__ = "('value', 'kind')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value', 'kind')"

    end_col_offset = None

    end_lineno = None

    kind = None

    n = "<property object at 0x000001303F3F2D40>"

    s = "<property object at 0x000001303F7F6AC0>"

class NamedExpr(expr):
    """NamedExpr(expr target, expr value)"""


    __match_args__ = "('target', 'value')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('target', 'value')"

    end_col_offset = None

    end_lineno = None

class NodeTransformer(NodeVisitor):
    """
        A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
        allows modification of nodes.

        The `NodeTransformer` will walk the AST and use the return value of the
        visitor methods to replace or remove the old node.  If the return value of
        the visitor method is ``None``, the node will be removed from its location,
        otherwise it is replaced with the return value.  The return value may be the
        original node in which case no replacement takes place.

        Here is an example transformer that rewrites all occurrences of name lookups
        (``foo``) to ``data['foo']``::

           class RewriteName(NodeTransformer):

               def visit_Name(self, node):
                   return Subscript(
                       value=Name(id='data', ctx=Load()),
                       slice=Constant(value=node.id),
                       ctx=node.ctx
                   )

        Keep in mind that if the node you're operating on has child nodes you must
        either transform the child nodes yourself or call the :meth:`generic_visit`
        method for the node first.

        For nodes that were part of a collection of statements (that applies to all
        statement nodes), the visitor may also return a list of nodes rather than
        just a single node.

        Usually you use the transformer like this::

           node = YourTransformer().visit(node)
        """


    __module__ = """ast"""

    def generic_visit(*args,**kw):
        pass

    def visit(*args,**kw):
        """Visit a node."""
        pass

    def visit_Constant(*args,**kw):
        pass


class Nonlocal(stmt):
    """Nonlocal(identifier* names)"""


    __match_args__ = "('names',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('names',)"

    end_col_offset = None

    end_lineno = None

class Not(unaryop):
    """Not"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class NotEq(cmpop):
    """NotEq"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class NotIn(cmpop):
    """NotIn"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Num(Constant):
    """Deprecated AST node class. Use ast.Constant instead"""


    __match_args__ = "('value', 'kind')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('n',)"

    end_col_offset = None

    end_lineno = None

    kind = None

    n = "<property object at 0x000001303F3F2D40>"

    s = "<property object at 0x000001303F7F6AC0>"

class Or(boolop):
    """Or"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Param(expr_context):
    """Deprecated AST node class.  Unused in Python 3."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Pass(stmt):
    """Pass"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "()"

    end_col_offset = None

    end_lineno = None

class Pow(operator):
    """Pow"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"
PyCF_ALLOW_TOP_LEVEL_AWAIT = 8192

PyCF_ONLY_AST = 1024

PyCF_TYPE_COMMENTS = 4096


class RShift(operator):
    """RShift"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Raise(stmt):
    """Raise(expr? exc, expr? cause)"""


    __match_args__ = "('exc', 'cause')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('exc', 'cause')"

    cause = None

    end_col_offset = None

    end_lineno = None

    exc = None

class Return(stmt):
    """Return(expr? value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

    end_col_offset = None

    end_lineno = None

    value = None

class Set(expr):
    """Set(expr* elts)"""


    __match_args__ = "('elts',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('elts',)"

    end_col_offset = None

    end_lineno = None

class SetComp(expr):
    """SetComp(expr elt, comprehension* generators)"""


    __match_args__ = "('elt', 'generators')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('elt', 'generators')"

    end_col_offset = None

    end_lineno = None

class Slice(expr):
    """Slice(expr? lower, expr? upper, expr? step)"""


    __match_args__ = "('lower', 'upper', 'step')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('lower', 'upper', 'step')"

    end_col_offset = None

    end_lineno = None

    lower = None

    step = None

    upper = None

class Starred(expr):
    """Starred(expr value, expr_context ctx)"""


    __match_args__ = "('value', 'ctx')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value', 'ctx')"

    end_col_offset = None

    end_lineno = None

class Store(expr_context):
    """Store"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Str(Constant):
    """Deprecated AST node class. Use ast.Constant instead"""


    __match_args__ = "('value', 'kind')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('s',)"

    end_col_offset = None

    end_lineno = None

    kind = None

    n = "<property object at 0x000001303F3F2D40>"

    s = "<property object at 0x000001303F7F6AC0>"

class Sub(operator):
    """Sub"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Subscript(expr):
    """Subscript(expr value, expr slice, expr_context ctx)"""


    __match_args__ = "('value', 'slice', 'ctx')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value', 'slice', 'ctx')"

    end_col_offset = None

    end_lineno = None

class Suite(mod):
    """Deprecated AST node class.  Unused in Python 3."""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class Try(stmt):
    """Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)"""


    __match_args__ = "('body', 'handlers', 'orelse', 'finalbody')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('body', 'handlers', 'orelse', 'finalbody')"

    end_col_offset = None

    end_lineno = None

class Tuple(expr):
    """Tuple(expr* elts, expr_context ctx)"""


    __match_args__ = "('elts', 'ctx')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('elts', 'ctx')"

    dims = "<property object at 0x000001303F7F7D80>"

    end_col_offset = None

    end_lineno = None

class TypeIgnore(type_ignore):
    """TypeIgnore(int lineno, string tag)"""


    __match_args__ = "('lineno', 'tag')"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "('lineno', 'tag')"

class UAdd(unaryop):
    """UAdd"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class USub(unaryop):
    """USub"""


    __match_args__ = "()"

    __module__ = """ast"""

    _attributes = "()"

    _fields = "()"

class UnaryOp(expr):
    """UnaryOp(unaryop op, expr operand)"""


    __match_args__ = "('op', 'operand')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('op', 'operand')"

    end_col_offset = None

    end_lineno = None

class While(stmt):
    """While(expr test, stmt* body, stmt* orelse)"""


    __match_args__ = "('test', 'body', 'orelse')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('test', 'body', 'orelse')"

    end_col_offset = None

    end_lineno = None

class With(stmt):
    """With(withitem* items, stmt* body, string? type_comment)"""


    __match_args__ = "('items', 'body', 'type_comment')"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('items', 'body', 'type_comment')"

    end_col_offset = None

    end_lineno = None

    type_comment = None

class Yield(expr):
    """Yield(expr? value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

    end_col_offset = None

    end_lineno = None

    value = None

class YieldFrom(expr):
    """YieldFrom(expr value)"""


    __match_args__ = "('value',)"

    __module__ = """ast"""

    _attributes = "('lineno', 'col_offset', 'end_lineno', 'end_col_offset')"

    _fields = "('value',)"

    end_col_offset = None

    end_lineno = None

class _ABC(type):

    __module__ = """ast"""

    mro = "<method 'mro' of 'type' objects>"
_ALL_QUOTES = "(\"'\", '\"', '\"\"\"', \"'''\")"

_INFSTR = """1e309"""

_MULTI_QUOTES = "('\"\"\"', \"'''\")"


class _Precedence(IntEnum):
    """Precedence table that originated from python grammar."""


    AND = 5

    ARITH = 12

    ATOM = 17

    AWAIT = 16

    BAND = 10

    BXOR = 9

    CMP = 7

    EXPR = 8

    FACTOR = 14

    NOT = 6

    OR = 4

    POWER = 15

    SHIFT = 11

    TERM = 13

    TEST = 3

    TUPLE = 1

    YIELD = 2

    __module__ = """ast"""
_SINGLE_QUOTES = "(\"'\", '\"')"


class _Unparser(NodeVisitor):
    """Methods in this class recursively traverse an AST and
        output source code for the abstract syntax; original formatting
        is disregarded."""


    __module__ = """ast"""

    def _for_helper(*args,**kw):
        pass

    def _fstring_Constant(*args,**kw):
        pass

    def _fstring_FormattedValue(*args,**kw):
        pass

    def _fstring_JoinedStr(*args,**kw):
        pass

    def _function_helper(*args,**kw):
        pass

    def _str_literal_helper(*args,**kw):
        """Helper for writing string literals, minimizing escapes.            Returns the tuple (string literal to write, possible quote types).
                """
        pass

    def _write_constant(*args,**kw):
        pass

    def _write_docstring(*args,**kw):
        pass

    def _write_docstring_and_traverse_body(*args,**kw):
        pass

    def _write_str_avoiding_backslashes(*args,**kw):
        """Write string literal value with a best effort attempt to avoid backslashes."""
        pass

    binop = {'Add': '+', 'Sub': '-', 'Mult': '*', 'MatMult': '@', 'Div': '/', 'Mod': '%', 'LShift': '<<', 'RShift': '>>', 'BitOr': '|', 'BitXor': '^', 'BitAnd': '&', 'FloorDiv': '//', 'Pow': '**'}

    binop_precedence = {'+': 12, '-': 12, '*': 13, '@': 13, '/': 13, '%': 13, '<<': 11, '>>': 11, '|': 8, '^': 9, '&': 10, '//': 13, '**': 15}

    binop_rassoc = "frozenset({'**'})"

    def block(*args,**kw):
        """A context manager for preparing the source for blocks. It adds            the character':', increases the indentation on enter and decreases
                the indentation on exit. If *extra* is given, it will be directly
                appended after the colon character.
                """
        pass

    boolop_precedence = {'and': 5, 'or': 4}

    boolops = {'And': 'and', 'Or': 'or'}

    buffer = "<property object at 0x000001303F818090>"

    def buffer_writer(*args,**kw):
        pass

    cmpops = {'Eq': '==', 'NotEq': '!=', 'Lt': '<', 'LtE': '<=', 'Gt': '>', 'GtE': '>=', 'Is': 'is', 'IsNot': 'is not', 'In': 'in', 'NotIn': 'not in'}

    def delimit(*args,**kw):
        """A context manager for preparing the source for expressions. It adds            *start* to the buffer and enters, after exit it adds *end*."""
        pass

    def delimit_if(*args,**kw):
        pass

    def fill(*args,**kw):
        """Indent a piece of text and append it, according to the current            indentation level"""
        pass

    def generic_visit(*args,**kw):
        """Called if no explicit visitor function exists for a node."""
        pass

    def get_precedence(*args,**kw):
        pass

    def get_raw_docstring(*args,**kw):
        """If a docstring node is found in the body of the *node* parameter,            return that docstring node, None otherwise.

                Logic mirrored from ``_PyAST_GetDocString``."""
        pass

    def get_type_comment(*args,**kw):
        pass

    def interleave(*args,**kw):
        """Call f on each item in seq, calling inter() in between."""
        pass

    def items_view(*args,**kw):
        """Traverse and separate the given *items* with a comma and append it to            the buffer. If *items* is a single item sequence, a trailing comma
                will be added."""
        pass

    def maybe_newline(*args,**kw):
        """Adds a newline if it isn't the start of generated source"""
        pass

    def require_parens(*args,**kw):
        """Shortcut to adding precedence related parens"""
        pass

    def set_precedence(*args,**kw):
        pass

    def traverse(*args,**kw):
        pass

    unop = {'Invert': '~', 'Not': 'not', 'UAdd': '+', 'USub': '-'}

    unop_precedence = {'not': 6, '~': 14, '+': 14, '-': 14}

    def visit(*args,**kw):
        """Outputs a source code string that, if converted back to an ast            (using ast.parse) will generate an AST equivalent to *node*"""
        pass

    def visit_AnnAssign(*args,**kw):
        pass

    def visit_Assert(*args,**kw):
        pass

    def visit_Assign(*args,**kw):
        pass

    def visit_AsyncFor(*args,**kw):
        pass

    def visit_AsyncFunctionDef(*args,**kw):
        pass

    def visit_AsyncWith(*args,**kw):
        pass

    def visit_Attribute(*args,**kw):
        pass

    def visit_AugAssign(*args,**kw):
        pass

    def visit_Await(*args,**kw):
        pass

    def visit_BinOp(*args,**kw):
        pass

    def visit_BoolOp(*args,**kw):
        pass

    def visit_Break(*args,**kw):
        pass

    def visit_Call(*args,**kw):
        pass

    def visit_ClassDef(*args,**kw):
        pass

    def visit_Compare(*args,**kw):
        pass

    def visit_Constant(*args,**kw):
        pass

    def visit_Continue(*args,**kw):
        pass

    def visit_Delete(*args,**kw):
        pass

    def visit_Dict(*args,**kw):
        pass

    def visit_DictComp(*args,**kw):
        pass

    def visit_Ellipsis(*args,**kw):
        pass

    def visit_ExceptHandler(*args,**kw):
        pass

    def visit_Expr(*args,**kw):
        pass

    def visit_For(*args,**kw):
        pass

    def visit_FormattedValue(*args,**kw):
        pass

    def visit_FunctionDef(*args,**kw):
        pass

    def visit_FunctionType(*args,**kw):
        pass

    def visit_GeneratorExp(*args,**kw):
        pass

    def visit_Global(*args,**kw):
        pass

    def visit_If(*args,**kw):
        pass

    def visit_IfExp(*args,**kw):
        pass

    def visit_Import(*args,**kw):
        pass

    def visit_ImportFrom(*args,**kw):
        pass

    def visit_JoinedStr(*args,**kw):
        pass

    def visit_Lambda(*args,**kw):
        pass

    def visit_List(*args,**kw):
        pass

    def visit_ListComp(*args,**kw):
        pass

    def visit_Match(*args,**kw):
        pass

    def visit_MatchAs(*args,**kw):
        pass

    def visit_MatchClass(*args,**kw):
        pass

    def visit_MatchMapping(*args,**kw):
        pass

    def visit_MatchOr(*args,**kw):
        pass

    def visit_MatchSequence(*args,**kw):
        pass

    def visit_MatchSingleton(*args,**kw):
        pass

    def visit_MatchStar(*args,**kw):
        pass

    def visit_MatchValue(*args,**kw):
        pass

    def visit_Module(*args,**kw):
        pass

    def visit_Name(*args,**kw):
        pass

    def visit_NamedExpr(*args,**kw):
        pass

    def visit_Nonlocal(*args,**kw):
        pass

    def visit_Pass(*args,**kw):
        pass

    def visit_Raise(*args,**kw):
        pass

    def visit_Return(*args,**kw):
        pass

    def visit_Set(*args,**kw):
        pass

    def visit_SetComp(*args,**kw):
        pass

    def visit_Slice(*args,**kw):
        pass

    def visit_Starred(*args,**kw):
        pass

    def visit_Subscript(*args,**kw):
        pass

    def visit_Try(*args,**kw):
        pass

    def visit_Tuple(*args,**kw):
        pass

    def visit_UnaryOp(*args,**kw):
        pass

    def visit_While(*args,**kw):
        pass

    def visit_With(*args,**kw):
        pass

    def visit_Yield(*args,**kw):
        pass

    def visit_YieldFrom(*args,**kw):
        pass

    def visit_alias(*args,**kw):
        pass

    def visit_arg(*args,**kw):
        pass

    def visit_arguments(*args,**kw):
        pass

    def visit_comprehension(*args,**kw):
        pass

    def visit_keyword(*args,**kw):
        pass

    def visit_match_case(*args,**kw):
        pass

    def visit_withitem(*args,**kw):
        pass

    def write(*args,**kw):
        """Append a piece of text"""
        pass

NoneType = type(None)
ellipsis= type(...)

_const_node_type_names = {bool: 'NameConstant', type(None): 'NameConstant', int: 'Num', float: 'Num', complex: 'Num', str: 'Str', bytes: 'Bytes', type('...'): 'Ellipsis'}

_const_types = {Num: (int, float, complex), Str: (str,), Bytes: (bytes,), NameConstant: (NoneType, bool), Ellipsis: (ellipsis,)}

_const_types_not = {Num: (bool,)}

def _dims_getter(*args,**kw):
    """Deprecated. Use elts instead."""
    pass

def _dims_setter(*args,**kw):
    pass

def _getter(*args,**kw):
    """Deprecated. Use value instead."""
    pass

def _new(*args,**kw):
    pass

def _pad_whitespace(*args,**kw):
    """Replace all chars except '\f\t' in a line with spaces."""
    pass

def _setter(*args,**kw):
    pass

def _splitlines_no_ff(*args,**kw):
    """Split a string into lines ignoring form feed and other chars.
        This mimics how the Python parser splits source code.
        """
    pass


class auto(object):
    """
        Instances are replaced with an appropriate value in Enum class suites.
        """


    __module__ = """enum"""

    value = "<object object at 0x000001303EEB46F0>"


def contextmanager(*args,**kw):
    """@contextmanager decorator.
        Typical usage:

            @contextmanager
            def some_generator(<arguments>):
                <setup>
                try:
                    yield <value>
                finally:
                    <cleanup>

        This makes this:

            with some_generator(<arguments>) as <variable>:
                <body>

        equivalent to this:

            <setup>
            try:
                <variable> = <value>
                <body>
            finally:
                <cleanup>
        """
    pass

def copy_location(*args,**kw):
    """        Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`
        attributes) from *old_node* to *new_node* if possible, and return *new_node*.
        """
    pass

def dump(*args,**kw):
    """        Return a formatted dump of the tree in node.  This is mainly useful for
        debugging purposes.  If annotate_fields is true (by default),
        the returned string will show the names and the values for fields.
        If annotate_fields is false, the result string will be more compact by
        omitting unambiguous field names.  Attributes such as line
        numbers and column offsets are not dumped by default.  If this is wanted,
        include_attributes can be set to true.  If indent is a non-negative
        integer or string, then the tree will be pretty-printed with that indent
        level. None (the default) selects the single line representation.
        """
    pass


def fix_missing_locations(*args,**kw):
    """        When you compile a node tree with compile(), the compiler expects lineno and
        col_offset attributes for every node that supports them.  This is rather
        tedious to fill in for generated nodes, so this helper adds these attributes
        recursively where not already set, by setting them to the values of the
        parent node.  It works recursively starting at *node*.
        """
    pass

def get_docstring(*args,**kw):
    """        Return the docstring for the given node or None if no docstring can
        be found.  If the node provided does not have docstrings a TypeError
        will be raised.

        If *clean* is `True`, all tabs are expanded to spaces and any whitespace
        that can be uniformly removed from the second line onwards is removed.
        """
    pass

def get_source_segment(*args,**kw):
    """Get source code segment of the *source* that generated *node*.
        If some location information (`lineno`, `end_lineno`, `col_offset`,
        or `end_col_offset`) is missing, return None.

        If *padded* is `True`, the first line of a multi-line statement will
        be padded with spaces to match its original position.
        """
    pass

def increment_lineno(*args,**kw):
    """        Increment the line number and end line number of each node in the tree
        starting at *node* by *n*. This is useful to "move code" to a different
        location in a file.
        """
    pass

def iter_child_nodes(*args,**kw):
    """        Yield all direct child nodes of *node*, that is, all fields that are nodes
        and all items of fields that are lists of nodes.
        """
    pass

def iter_fields(*args,**kw):
    """        Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
        that is present on *node*.
        """
    pass


def literal_eval(*args,**kw):
    """        Safely evaluate an expression node or a string containing a Python
        expression.  The string or node provided may only consist of the following
        Python literal structures: strings, bytes, numbers, tuples, lists, dicts,
        sets, booleans, and None.
        """
    pass

def main(*args,**kw):
    pass


def parse(*args,**kw):
    """        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
    pass


def unparse(*args,**kw):
    pass

def walk(*args,**kw):
    """        Recursively yield all descendant nodes in the tree starting at *node*
        (including *node* itself), in no specified order.  This is useful if you
        only want to modify nodes in place and don't care about the context.
        """
    pass

